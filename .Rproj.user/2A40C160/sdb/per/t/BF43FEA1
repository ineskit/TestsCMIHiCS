{
    "collab_server" : "",
    "contents" : "#include <Rcpp.h>\n#include \"CMI2.h\"\n\n#include <shark/Algorithms/KMeans.h> //k-means algorithm\n#include <shark/Models/Clustering/Centroids.h>//model performing hard clustering of points\n#include <shark/Models/Clustering/HardClusteringModel.h>//model performing hard clustering of points\n#include \"utils.h\" // some conversion helpers\n\nusing namespace Rcpp;\nusing namespace shark;\n// [[Rcpp::plugins(cpp11)]]\n\nNumericVector SharkKMeansTrain2 (NumericMatrix X, ssize_t k) {\n  UnlabeledData<RealVector> data = NumericMatrixToUnlabeledData(X);\n\n  Centroids centroids;\n  kMeans (data, k, centroids);\n\n  HardClusteringModel<RealVector> model(&centroids);\n  Data<unsigned> clusters = model(data);\n\n  return(LabelsToNumericVector(clusters));\n}\n\n\ndouble calcHce2(std::vector<double> dataVector) {\n  double hce = 0.0;\n  std::sort (dataVector.begin(), dataVector.end());\n\n  for(unsigned int i=0; i<dataVector.size()-1; ++i){\n    double tmp = double(i+1)/dataVector.size();\n    hce += (dataVector[i+1] - dataVector[i]) * tmp * log(tmp);\n  }\n  return -hce;\n}\n\n\n\n\ndouble calcCHce2(Rcpp::NumericMatrix data, std::vector<int> dim, unsigned int numClust){\n  double chce = 0.0;\n  int datarows = data.nrow();\n\n  std::vector<int> conDim = dim;\n\n  int refDim = dim.back();\n  conDim.pop_back(); // delete the refDim (per def.: the last element)\n\n  // Subset: only conditional dim. of the data-matrix\n  NumericMatrix MatConDim(data.nrow(), conDim.size());\n\n  for (unsigned int i=0; i<conDim.size(); i++){\n     MatConDim(_,i) = data(_,conDim[i]-1);\n  }\n\n  //call kmeans\n   NumericVector labels = SharkKMeansTrain2(MatConDim, numClust);\n\n\n  // calc chce per cluster\n  for (unsigned int c=0; c<numClust; c++){\n    // determine clustersize\n    int clustersize = std::count_if(labels.begin(), labels.end(), [c](unsigned int i) {return i == c;});\n\n    NumericVector vecRefDim = data(_,refDim-1);\n    std::vector<double> vRD = Rcpp::as<std::vector<double> >(vecRefDim);\n    std::vector<double> labelsVec = Rcpp::as<std::vector<double> >(labels);\n    std::vector<double> vRD2;\n    vRD2.clear();\n    for(unsigned int i=0; i<labelsVec.size(); ++i){\n\n      if (labelsVec[i] == c) {\n        vRD2.push_back(vRD[i]);\n      }\n    }\n\n    if (vRD2.size()!= 0){\n        chce = chce + clustersize/double(datarows) * calcHce2(vRD2);\n    }\n  }\n  return chce;\n}\n\n\ndouble best2DimProjection2(Rcpp::NumericVector subspace, Rcpp::NumericMatrix data, unsigned int numCluster,  std::vector<int> &best2dim){\n\n  double maxContrast = 0.0;\n\n  for (int i=0; i<subspace.size(); i++){\n    for(int j=0; j<subspace.size(); j++){\n      if(i!=j){\n        NumericVector attr = data( _, subspace[i]-1);\n        std::vector<double> dat = Rcpp::as<std::vector<double> >(attr);\n        std::vector<int> subs;\n        subs.clear();\n        subs.push_back(subspace[j]);\n        subs.push_back(subspace[i]);\n\n        double tmpContrast = calcHce2(dat) - calcCHce2(data, subs, numCluster);\n\n        if(tmpContrast >= maxContrast){\n          best2dim.clear();\n          best2dim.push_back(subspace[j]); //condDim\n          best2dim.push_back(subspace[i]); //refDim\n          maxContrast = tmpContrast;\n        }\n      }\n    }\n  }\n  return maxContrast;\n}\n\n\ndouble addDimToPermutation2(Rcpp::NumericMatrix data, std::vector<int> & permutation, std::vector<int> remainingDimensions, unsigned int numCluster){\n  double pNextdimContrast = 0.0;\n  int nextDim;\n\n  for(unsigned int i=0; i<remainingDimensions.size(); i++) {\n    permutation.push_back(remainingDimensions[i]);\n\n    double tmp = 0.0;\n\n    NumericVector nv = data( _, remainingDimensions[i]-1);\n\n    std::vector<double> d = Rcpp::as<std::vector<double> >(nv);\n\n    tmp = calcHce2(d) - calcCHce2(data, permutation, numCluster);\n\n    if(tmp >= pNextdimContrast){\n      nextDim = remainingDimensions[i];\n      pNextdimContrast = tmp;\n    }\n    permutation.pop_back();\n  }\n  permutation.push_back(nextDim);\n  return pNextdimContrast;\n}\n\n\ndouble cmi2(Rcpp::NumericMatrix data, Rcpp::NumericVector subspace, unsigned int numCluster){\n  double cmiContrast = 0.0;\n  std::vector<int> permutation;\n\n  //2-dim projections\n  cmiContrast = best2DimProjection2(subspace, data, numCluster, permutation);\n\n  // remaining dimensions\n  std::vector<int> remainingDimensions = Rcpp::as<std::vector<int>>(subspace);\n\n  // remove the best 2dim Projection from the remainingDimensions\n  remainingDimensions.erase(std::remove_if(remainingDimensions.begin(),\n                                           remainingDimensions.end(),\n                                           [permutation](int i) {return (i == permutation[0] or i == permutation[1]);}\n  ),remainingDimensions.end());\n\n  // add remaining dimensions to permutation\n  while(remainingDimensions.size() > 0){\n    cmiContrast += addDimToPermutation2(data, permutation, remainingDimensions, numCluster);\n\n\n    remainingDimensions.erase(std::remove(remainingDimensions.begin(),\n                                          remainingDimensions.end(),\n                                          permutation[permutation.size()-1]),remainingDimensions.end());\n  }\n  return cmiContrast;\n}\n",
    "created" : 1477487978590.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "162991008",
    "id" : "BF43FEA1",
    "lastKnownWriteTime" : 1476194503,
    "last_content_update" : 1476194503,
    "path" : "D:/Uni/SS16/Hiwi/github/R-subcon/src/CMI2.cpp",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}