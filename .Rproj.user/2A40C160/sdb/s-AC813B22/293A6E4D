{
    "collab_server" : "",
    "contents" : "library(subcon)\nlibrary(data.table)\nlibrary(foreign)\nlibrary(doSNOW)\nlibrary(dplyr)\n\nLog <- function(text, ...) {\n  msg <- sprintf(paste0(as.character(Sys.time()), \": \", text, \"\\n\"), ...)\n  cat(msg)\n}\n\nimportData <- function(inputPath, fileName){\n  if(grepl(\".csv\", fileName)){\n    dataset_labeled <- fread(paste0(inputPath, \"/\", fileName))\n  }else{\n    dataset_labeled <- as.data.table(read.arff(paste0(inputPath,\"/\", fileName)))\n  }\n  if(\"id\" %in% names(dataset_labeled)){\n    dataset_labeled <- dataset_labeled[,!\"id\", with=F]\n  }\n  if(\"outlier\" %in% names(dataset_labeled)) {\n    names(dataset_labeled)[which(names(dataset_labeled)==\"outlier\")] <- \"class\"\n  }\n  if(!(\"class\" %in% names(dataset_labeled))) {\n    names(dataset_labeled)[ncol(dataset_labeled)] <- \"class\"\n  }\n  if(\"yes\" %in% levels(dataset_labeled$class)){\n    dataset_labeled$class <- as.numeric(dataset_labeled$class == \"yes\")\n  }else{\n    if(is.factor(dataset_labeled$class)){\n      dataset_labeled$class <- as.numeric(levels(dataset_labeled$class))[dataset_labeled$class]\n    }\n    dataset_labeled[,class:=ifelse(class>0, 1, 0),]\n  }\n  dataset_labeled\n}\n\nrunLOF <- function(subspaces, data, minPts){\n  lapply(subspaces, function(x) {\n    tmp <- LOF(data[,unlist(x), with=F], k = minPts)\n    tmp[!is.finite(tmp)] <- 1\n    return(tmp)\n  })\n}\n\napplyLOF <- function(outputSpaces, data, label, maxMinPts, input, algorithm){\n  tmpResult <- foreach(k = seq(10, min(nrow(data) - 1, maxMinPts), by= 10)) %do% {\n    Log(paste0(\"input: \", input, \" algorithm: \", algorithm, \" k: \", k))\n    # outlier detection\n    uniqueOutputSpaces <- unique(lapply(outputSpaces, sort)) # remove exact duplicate subspaces\n    lofactors <- runLOF(subspaces = uniqueOutputSpaces, data = data, minPts = k)\n\n    # summarize the number of subspaces that hold the max score for an object\n    numberMaxScoreSubspaces <- data.table(matrix(unlist(lofactors), ncol=length(label), byrow = T)) %>%\n      summarize_all(which.max) %>%\n      as.numeric %>%\n      unique %>%\n      length\n\n    finalScoreMax <- Reduce(maxCombination, lofactors)\n    finalScoreSum <- Reduce(sumCombination, lapply(lofactors, identity))\n\n    # evaluation\n    # auc_sum <- combinedScoreAUC(combinationFun = sumCombination, scores = lofactors, label = label)\n    # auc_max <- combinedScoreAUC(combinationFun = maxCombination, scores = lofactors, label = label)\n\n    Rprecision_adj_sum <- precisionAtN(label, finalScoreSum, n = sum(label), adjusted = T)\n    Rprecision_adj_max <- precisionAtN(label, finalScoreMax, n = sum(label), adjusted = T)\n\n    auc_sum <- redundancyAUC(scores = lofactors, label = label, combinationFun = sumCombination, scaleFun = identity)\n    auc_max <- redundancyAUC(scores = lofactors, label = label, combinationFun = maxCombination, scaleFun = identity)\n\n    data.table(\"AUC_sum\" = auc_sum$initialAUC,\n               \"Rprecision_adj_sum\" = Rprecision_adj_sum,\n               \"numberRemainingSpaces_sum\" = auc_sum$numberRemainingSpaces,\n               \"AUC_removedRedundant_sum\" = auc_sum$maximumAUC,\n\n               \"AUC_max\" = auc_max$initialAUC,\n               \"Rprecision_adj_max\" = Rprecision_adj_max,\n               \"numberRemainingSpaces_max\" = auc_max$numberRemainingSpaces,\n               \"AUC_removedRedundant_max\" = auc_max$maximumAUC,\n\n               \"totalNumberSubspaces\" = length(uniqueOutputSpaces),\n               \"numberMaxScoreSubspaces\" = numberMaxScoreSubspaces,\n               \"minPts\" = k)\n  }\n\n  data.table(Reduce(rbind, tmpResult))\n}\n\nsubspaceSearch <- function(data, alpha, numRuns, algorithm, topkSearch, topkOutput){\n  sampleSize <- 1000\n  if(nrow(data)>sampleSize){\n    sampledata <- data[sample(.N, sampleSize)]\n    Log(paste0(\"Data set has \", nrow(data),\" rows. Sampling down to \", sampleSize, \" rows.\"))\n  }\n  else{\n    sampledata <- data\n  }\n  indexMatrix <- sortedIndexMatrix(sampledata)\n  numMatrix <- data.matrix(data)\n\n  addTrivialSpaces <- function(subspaces, numDim){\n    subspaces[[length(subspaces) + 1]] <- c(1:numDim) # add full space\n    subspaces <- c(subspaces, 1:numDim) # add single dimensions\n    subspaces\n  }\n\n  resList <- list()\n  switch(algorithm,\n         GMD = {\n           outputSpaces <- GMD(indexMap = indexMatrix, alpha, numRuns)\n         },\n         HiCS = {\n           capture.output(hicsSearchResult <- HiCSSearch(indexMap = indexMatrix, alpha, numRuns, topkSearch = topkSearch, topkOutput = topkOutput), file = NULL)\n\n           resList$outputSpaces <- hicsSearchResult$subspaces\n           resList$contrast     <- hicsSearchResult$contrast\n         },\n         FS = {\n           outputSpaces <- list(1:ncol(sampledata))\n         },\n         HiCSSO = {\n           capture.output(hicsSearchResult <- HiCSSearch(indexMap = indexMatrix, alpha, numRuns, topkSearch = topkSearch, topkOutput = topkOutput), file = NULL)\n           outputSpaces <- hicsSearchResult$subspaces\n           outputSpaces <- addTrivialSpaces(outputSpaces, ncol(sampledata))\n           contrast     <- hicsSearchResult$contrast\n         },\n         GMDSO = {\n           outputSpaces <- GMD(indexMap = indexMatrix, alpha, numRuns)\n           outputSpaces <- addTrivialSpaces(outputSpaces, ncol(sampledata))\n         },\n         CMI = {\n           CMIResult = CMISearch(data = numMatrix, numCluster = 10, topkSearch = topkSearch, topkOutput = topkOutput)\n           resList$outputSpaces <- CMIResult$subspaces\n           resList$contrast     <- CMIResult$contrast\n         }\n  )\n  Log(paste0(algorithm, \": found \", length(resList$outputSpaces), \" subspaces.\"))\n  return (resList)\n}\n\nrunExperiments <- function(inputPath,\n                           outputFolder=\"results\",\n                           outputFile=\"experimentResult.RData\",\n                           numCores = 1,\n                           alpha = 0.1,\n                           numRuns = 100,\n                           maxMinPts = 100,\n                           logFile=\"\",\n                           topkSearch = 500,\n                           topkOutput = 100){\n\n  # setup\n  Log(\"starting experiments\")\n  inputs <- list.files(path=inputPath, recursive = T)\n   algorithms <- c(\"HiCS\", \"CMI\")\n\n  \n  experiments <- expand.grid(\"algorithm\" = algorithms, \"input\" = inputs, stringsAsFactors = FALSE)\n\n  resultSet <- data.table()\n\n  if(numCores > 1){\n    Log(paste0(\"setting up parallel cluster with \", numCores, \" cores...\"))\n    cluster <- makeCluster(numCores, type = \"SOCK\", outfile=logFile)\n    registerDoSNOW(cluster)\n  }else{\n    Log(paste0(\"running in sequential mode...\"))\n    registerDoSEQ()\n  }\n\n  t0 <- proc.time()\n\n  parallelResult <- foreach(i=1:nrow(experiments),\n                            .packages=c(\"foreign\", \"data.table\", \"subcon\", \"foreach\", \"dplyr\"),\n                            .export=c(\"subspaceSearch\", \"applyLOF\", \"runLOF\", \"Log\", \"importData\")) %do% {\n\n                              experiment <- experiments[i,]\n\n                              dataset_labeled <- importData(inputPath, experiment$input)\n                              dt <- data.table(dataset_labeled)\n                              label <- dt$class\n                              dt <- dt[,-c(\"class\"), with=F]\n\n                              timer_start <- proc.time()\n                              rL <- subspaceSearch(data = dt, alpha, numRuns, algorithm = experiment$algorithm, topkSearch, topkOutput)\n                              timer_end <- proc.time()\n\n                              timer_start_LOF <- proc.time()\n                              result <- applyLOF(outputSpaces = rL$outputSpaces, data=dt, label=label, maxMinPts = maxMinPts, input = experiment$input, algorithm = experiment$algorithm)\n                              timer_end_LOF <- proc.time()\n\n                              # for (i in 1:5) {\n                              #   subspX <- sapply(outputSpaces[i], function(x) paste0(\"[\",paste(x, collapse = \",\"),\"]\"))\n                              #   header<-paste0(\"Top_\",i)\n                              #   top5SS$header <- subspX\n                              #   #top5SS <- data.table(header = subspX)\n                              # }\n                              subsp1 <- sapply(rL$outputSpaces[1], function(x) paste0(\"[\",paste(x, collapse = \",\"),\"]\"))\n                              subsp2 <- sapply(rL$outputSpaces[2], function(x) paste0(\"[\",paste(x, collapse = \",\"),\"]\"))\n                              subsp3 <- sapply(rL$outputSpaces[3], function(x) paste0(\"[\",paste(x, collapse = \",\"),\"]\"))\n                              subsp4 <- sapply(rL$outputSpaces[4], function(x) paste0(\"[\",paste(x, collapse = \",\"),\"]\"))\n                              subsp5 <- sapply(rL$outputSpaces[5], function(x) paste0(\"[\",paste(x, collapse = \",\"),\"]\"))\n                              top5SS <- data.table(subsp1, subsp2, subsp3, subsp4, subsp5)\n                              \n                              data.table(cbind(algorithm = experiment$algorithm, dataset = experiment$input, duationSS = (timer_end -timer_start)[\"elapsed\"],\n                                               durationLOF = (timer_end_LOF - timer_start_LOF)[\"elapsed\"], result, top5SS, Highestcontrast =rL$contrast[1]))\n                            \n                              # top 5 subspaces:\n                              #top5SS<-data.table(cbind(subspaces = outputSpaces[1:5]), contrast = contrastCMI)\n                            }\n\n  combinedResult <- data.table(Reduce(rbind, parallelResult))\n\n  print(paste0(\"total duration experiment: \", (proc.time() - t0)[\"elapsed\"]))\n  # store result\n\n  save(combinedResult, file=paste0(outputFolder,\"/\",outputFile))\n  \n  #outputFileEnh <- paste0(outputFile, \"_enh\")\n  #save(top5SS, file=paste0(outputFolder,\"/\",outputFileEnh))\n  # cleanup\n  if(numCores > 1){\n    stopCluster(cluster)\n  }\n  combinedResult\n}\n\n  # finalResult <- runExperiments(inputPath = \"datasets\", maxMinPts = 100, numCores=1, topkSearch = 500, topkOutput = 100)\n\n",
    "created" : 1476194745217.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "977488387",
    "id" : "293A6E4D",
    "lastKnownWriteTime" : 1476864737,
    "last_content_update" : 1476864737169,
    "path" : "D:/Uni/SS16/Hiwi/github/TestsCMIHiCS/HICSvsCMI_Experiments.R",
    "project_path" : "HICSvsCMI_Experiments.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}